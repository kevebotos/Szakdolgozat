{
	"nodes":[
		{"id":"meshload","type":"text","text":"## 4) Háló beolvasása (Gmsh 2.x)\n\n```cpp\nMesh M;\nif (!load_msh2(meshPath, M, std::cout)) {\n  std::cerr << \"Sikertelen hálóbeolvasás.\\n\";\n  return 1;\n}\n```\n- `load_msh2` feltölti a `Mesh` struktúrát (csomópontok, háromszögek, phys nevek, BBox).\n- Sikertelen olvasásnál hibával kilép.","x":-680,"y":620,"width":560,"height":318},
		{"id":"includes","type":"text","text":"## 1) Fejlécek – modulok és miért kellenek\n\n```cpp\n#include \"mesh.hpp\"\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <cstring>\n```\n- **mesh.hpp**: `Mesh` struktúra, `load_msh2` deklaráció.\n- **iostream**: ki-/bemenet (`std::cout`, `std::cerr`).\n- **unordered_map / unordered_set**: gyors halmazok/táblák.\n- **cmath**: `std::fabs`, `std::max`.\n- **cstring**: `std::strcmp` a CLI kapcsolókhoz.","x":-40,"y":-60,"width":560,"height":397},
		{"id":"compute_eps","type":"text","text":"## 2) Segédfüggvény: compute_eps\nMéretarányos tűrés a BBox alapján – lebegőpontos zaj kiszűrésére perem-ellenőrzésnél.\n\n```cpp\nstatic double compute_eps(const Mesh &m) {\n  const double dx = m.maxx - m.minx;\n  const double dy = m.maxy - m.miny;\n  const double scale = std::max(dx, dy);\n  return std::max(1e-12, scale * 1e-9);\n}\n```\n- `scale` a háló kiterjedésének max dimenziója.\n- `eps` sosem megy 1e-12 alá (numerikus biztonság).","x":-40,"y":360,"width":560,"height":382},
		{"id":"argparse","type":"text","text":"## 3) Parancssori argumentumok: --mesh / -m\nAlapértelmezett: `stove.msh`. Kapcsolóval felülírható.\n\n```cpp\nstd::string meshPath = \"stove.msh\";\nfor (int i = 1; i < argc; ++i) {\n  if ((std::strcmp(argv[i], \"--mesh\") == 0 ||\n       std::strcmp(argv[i], \"-m\") == 0) && i + 1 < argc) {\n    meshPath = argv[++i];\n  }\n}\n```\n- `std::strcmp`: C-stílusú összehasonlítás.\n- `++i`: az értékre léptetünk (következő argv).","x":-40,"y":820,"width":560,"height":382},
		{"id":"burners","type":"text","text":"## 9) Égők csomópontjai (phys 101–104)\n\n```cpp\nauto is_burner = [&](int phys)\n{ return phys == 101 || phys == 102 || phys == 103 || phys == 104; };\n\nstd::unordered_set<int> burnerNodes;\nfor (const auto &t : M.tris) {\n  if (is_burner(t.phys)) {\n    burnerNodes.insert(t.a);\n    burnerNodes.insert(t.b);\n    burnerNodes.insert(t.c);\n  }\n}\nstd::cout << \"  Égőkhöz tartozó (belső) csomópontok (összesen): \"\n          << burnerNodes.size() << \" db\\n\";\n```\n- Lambda a phys-ID szűrésre.\n- Halmaz: csúcsok egyedisége biztosított.","x":-680,"y":1120,"width":560,"height":540},
		{"id":"meshinfo","type":"text","text":"## 5) Háló-statisztikák + BBox\n\n```cpp\nconst std::size_t N = (M.nodes.size() > 0 ? M.nodes.size() - 1 : 0);\nstd::cout << \"[OK] Háló beolvasva:\\n\";\nstd::cout << \"  Csomópontok: \" << N << \"\\n\";\nstd::cout << \"  Háromszögek: \" << M.tris.size() << \"\\n\";\nstd::cout << \"  BBox: [\" << M.minx << \", \" << M.miny << \"] — [\" << M.maxx << \", \" << M.maxy << \"]\\n\";\n```\n- **1-indexelt** csomóponttömb miatt `-1` korrekció.\n- BBox: min/max X-Y koordináták.","x":-1320,"y":560,"width":560,"height":342},
		{"id":"end","type":"text","text":"## 10) Lezárás\n\n```cpp\nstd::cout << \"\\nMinden rendben. Következő lépés: FEM megoldó + PPM hőtérkép.\\n\";\nreturn 0;\n```\n- Kiírás + sikeres kilépés.\n- Következő fejlesztési irányok: FEM, peremfeltételek, VTK/VTU export.","x":-40,"y":1255,"width":560,"height":270},
		{"id":"outer","type":"text","text":"## 8) Külső perem csomópontok (BBox-hoz közeli)\n\n```cpp\nconst double eps = compute_eps(M);\nstd::unordered_set<int> outer;\nfor (int id = 1; id <= static_cast<int>(N); ++id) {\n  const auto &p = M.nodes[id];\n  if (std::fabs(p.x - M.minx) <= eps || std::fabs(p.x - M.maxx) <= eps ||\n      std::fabs(p.y - M.miny) <= eps || std::fabs(p.y - M.maxy) <= eps) {\n    outer.insert(id);\n  }\n}\nstd::cout << \"  Külső perem (geometriai) csomópontok: \" << outer.size() << \" db\\n\";\n```\n- **eps**: méretarányos tűrés a perem-azonosításhoz.\n- `unordered_set`: egyediség biztosítása.","x":-1320,"y":1120,"width":560,"height":520},
		{"id":"tricount","type":"text","text":"## 7) Háromszög-darabszám physical csoportonként\n\n```cpp\nstd::unordered_map<int, std::size_t> triCount;\nfor (const auto &t : M.tris)\n  triCount[t.phys]++;\n\nfor (const auto &kv : triCount) {\n  int id = kv.first; std::size_t cnt = kv.second;\n  auto it = M.physNames.find(id);\n  std::string name = (it != M.physNames.end() ? it->second : std::string(\"<nincs név>\"));\n  std::cout << \"    phys=\" << id << \" (\" << name << \") : \" << cnt << \" db\\n\";\n}\n```\n- Gyors számlálás hash-mapben.\n- Név feloldása, ha ismert.","x":-1240,"y":2120,"width":560,"height":420},
		{"id":"physnames","type":"text","text":"## 6) Fizikai csoportnevek listázása\n\n```cpp\nif (!M.physNames.empty()) {\n  std::cout << \"  Physical names (id → név):\\n\";\n  for (const auto &kv : M.physNames) {\n    std::cout << \"    \" << kv.first << \" → \" << kv.second << \"\\n\";\n  }\n}\n```\n- `physNames`: id → szöveges név (pl. burner régiók).","x":-2110,"y":1660,"width":560,"height":420},
		{"id":"code_full","type":"text","text":"# TELJES forrás: main.cpp\n\n```cpp\n#include \"mesh.hpp\"\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <cstring>\n\nstatic double compute_eps(const Mesh &m)\n{\n  const double dx = m.maxx - m.minx;\n  const double dy = m.maxy - m.miny;\n  const double scale = std::max(dx, dy);\n  return std::max(1e-12, scale * 1e-9); // nagyon kicsi, de a bbox-hoz igazodik\n}\n\nint main(int argc, char **argv)\n{\n  std::string meshPath = \"stove.msh\"; // alapértelmezett a projekt gyökerében\n  for (int i = 1; i < argc; ++i)\n  {\n    if ((std::strcmp(argv[i], \"--mesh\") == 0 || std::strcmp(argv[i], \"-m\") == 0) && i + 1 < argc)\n    {\n      meshPath = argv[++i];\n    }\n  }\n\n  Mesh M;\n  if (!load_msh2(meshPath, M, std::cout))\n  {\n    std::cerr << \"Sikertelen hálóbeolvasás.\\n\";\n    return 1;\n  }\n\n  const std::size_t N = (M.nodes.size() > 0 ? M.nodes.size() - 1 : 0);\n  std::cout << \"[OK] Háló beolvasva:\\n\";\n  std::cout << \"  Csomópontok: \" << N << \"\\n\";\n  std::cout << \"  Háromszögek: \" << M.tris.size() << \"\\n\";\n  std::cout << \"  BBox: [\" << M.minx << \", \" << M.miny << \"] — [\" << M.maxx << \", \" << M.maxy << \"]\\n\";\n\n  // Fizikai csoport névlista\n  if (!M.physNames.empty())\n  {\n    std::cout << \"  Physical names (id → név):\\n\";\n    for (const auto &kv : M.physNames)\n    {\n      std::cout << \"    \" << kv.first << \" → \" << kv.second << \"\\n\";\n    }\n  }\n\n  // Háromszög darabszám fizikai csoportonként\n  std::unordered_map<int, std::size_t> triCount;\n  for (const auto &t : M.tris)\n    triCount[t.phys]++;\n\n  std::cout << \"  Háromszögek fizikai csoportonként:\\n\";\n  for (const auto &kv : triCount)\n  {\n    int id = kv.first;\n    std::size_t cnt = kv.second;\n    auto it = M.physNames.find(id);\n    std::string name = (it != M.physNames.end() ? it->second : std::string(\"<nincs név>\"));\n    std::cout << \"    phys=\" << id << \" (\" << name << \") : \" << cnt << \" db\\n\";\n  }\n\n  // Külső perem csomópontok (téglalap szélein)\n  const double eps = compute_eps(M);\n  std::unordered_set<int> outer;\n  for (int id = 1; id <= static_cast<int>(N); ++id)\n  {\n    const auto &p = M.nodes[id];\n    if (std::fabs(p.x - M.minx) <= eps || std::fabs(p.x - M.maxx) <= eps ||\n        std::fabs(p.y - M.miny) <= eps || std::fabs(p.y - M.maxy) <= eps)\n    {\n      outer.insert(id);\n    }\n  }\n  std::cout << \"  Külső perem (geometriai) csomópontok: \" << outer.size() << \" db\\n\";\n\n  // Égők (Burner 1..4) csomópontjai — háromszög-fizikai ID alapján\n  auto is_burner = [&](int phys)\n  { return phys == 101 || phys == 102 || phys == 103 || phys == 104; };\n  std::unordered_set<int> burnerNodes;\n  for (const auto &t : M.tris)\n  {\n    if (is_burner(t.phys))\n    {\n      burnerNodes.insert(t.a);\n      burnerNodes.insert(t.b);\n      burnerNodes.insert(t.c);\n    }\n  }\n  std::cout << \"  Égőkhöz tartozó (belső) csomópontok (összesen): \" << burnerNodes.size() << \" db\\n\";\n\n  std::cout << \"\\nMinden rendben. Következő lépés: FEM megoldó + PPM hőtérkép.\\n\";\n  return 0;\n}\n```","x":-2440,"y":-1134,"width":820,"height":2509},
		{"id":"root","type":"text","text":"# main.cpp – Áttekintés\n\n**Cél:** Beolvasni egy Gmsh 2-es verziós hálót, burner csomópontok kigyűjtése (phys 101-104), perempontok kigyűjtése (kis tűréssel).\n\n**Fő lépések:**\n1) Fejlécek, segédfüggvény (\\`compute_eps\\`).\n2) Parancssori argumentumok: \\`--mesh / -m\\`.\n3) Háló beolvasása: \\`load_msh2\\`.\n4) Statisztikák + fizikai nevek.\n5) Külső perem csomópontok (BBox + eps).\n6) Égőkhöz tartozó csomópontok (phys 101–104).\n7) Zárás, következő lépés jelzése.","x":-1040,"y":-60,"width":560,"height":398}
	],
	"edges":[
		{"id":"e1","fromNode":"root","fromSide":"left","toNode":"code_full","toSide":"right"},
		{"id":"e2","fromNode":"root","fromSide":"right","toNode":"includes","toSide":"left"},
		{"id":"e3","fromNode":"includes","fromSide":"bottom","toNode":"compute_eps","toSide":"top"},
		{"id":"e4","fromNode":"compute_eps","fromSide":"bottom","toNode":"argparse","toSide":"top"},
		{"id":"e5","fromNode":"argparse","fromSide":"left","toNode":"meshload","toSide":"right"},
		{"id":"e6","fromNode":"meshload","fromSide":"left","toNode":"meshinfo","toSide":"right"},
		{"id":"e7","fromNode":"meshinfo","fromSide":"left","toNode":"physnames","toSide":"right"},
		{"id":"e8","fromNode":"physnames","fromSide":"bottom","toNode":"tricount","toSide":"left"},
		{"id":"e9","fromNode":"meshinfo","fromSide":"bottom","toNode":"outer","toSide":"top"},
		{"id":"e10","fromNode":"tricount","fromSide":"right","toNode":"burners","toSide":"left"},
		{"id":"e11","fromNode":"burners","fromSide":"right","toNode":"end","toSide":"left"}
	]
}